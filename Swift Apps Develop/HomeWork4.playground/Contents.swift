import UIKit


//1. Создать массив [1, 3, 4, 4, 7, 5, 9, 5, 8, 5]. Создать новый массив, в котором не будет повторяющихся элементов
var arr = [1, 3, 4, 4, 7, 5, 9, 5, 8, 5]
var b = Array(Set(arr))
print(b)

//2. Написать функцию, которая на вход принимает массив целых чисел и возвращает минимальное и максимальное значение в массиве (вспоминаем кортежи). Если массив пуст - вернуть nil. Если минимальное и максимальное значение одинаковы - тоже вернуть nil
func minMaxElement (a: [Int]) -> (String, String)? {
    guard !a.isEmpty && a.min() != a.max() else  {
        return nil
    }
    return (String("\(a.min())"), String("\(a.max())"))
}
minMaxElement(a: [])
//3. Написать функцию, которая на вход принимает два массива целых чисел. Функция возвращает Bool. если массивы пусты или в них разное количество элементов - вернуть nil. Если в массивах есть на одних и тех же местах одинаковые элементы - вернуть true, если нет - false. Например, массивы [1, 2, 3] и [1, 5, 4] вернет true, так как 1 совпадает. [1, 5, 7, 8, 9] и [9, 7, 5, 1, 9] тоже вернет true - 9 в конце совпадает. А вот [1, 2, 3] и [4, 3, 1] вернет false - ни одного повторяющегося элемента (место и элемент должны совпадать)
func hasCommonElementsAtSameIndices (arr1: [Int], arr2: [Int]) -> Bool? {
    guard !arr1.isEmpty, !arr2.isEmpty, arr1.count == arr2.count else {
        return nil
    }
    for i in 0..<arr1.count {
        if arr1[i] == arr2[i] {
            return true
        }
    }
    return false
}
hasCommonElementsAtSameIndices(arr1: [1, 5, 7, 8, 9], arr2: [9, 7, 5, 1, 9])

//4. Написать функцию, которая на вход принимает строку и возвращает новую строку. Если строка, полученная на вход пуста - вернуть nil. Функция должна вернуть новую строку, состоящую из элементов входное строки, но не должно быть a, h, k.
func isAHK (a: String) -> String? {
    guard !a.isEmpty else {
        return nil
    }
    var b = a.filter { $0 != "a" && $0 != "h" && $0 != "k" }// тут сначал поставил || не сработало поставил &&, не понимаю почему тут И, а не ИЛИ
    let c: String? = b
    return c
}

isAHK(a: "hjkas")


//5. Написать функцию, которая на вход принимает строку и возвращает новую строку. Если строка, полученная на вход пуста - вернуть nil. Функция должна вернуть новую строку, состоящую из элементов входное строки, но должнs быть только a, h, k.

func isNotAHK (a: String) -> String? {
    guard !a.isEmpty else {
        return nil
    }
    var b = a.filter { $0 == "a" || $0 == "h" || $0 == "k" }// а тут наоборот, сделал как в задаче выше, но это не сработало, попробовал || и это сработало. Но тут не понимаю  почему ИЛИ, вернее тут я бы изначально ставил ИЛИ, если бы делал это задание первым, но покакой-то причине в предыдущем &&, тогда странно почему тут все таки || ИЛИ
    let c: String? = b
    return c
}

isNotAHK(a: "hjkas")

//6. Написать функцию, которая на вход принимает два массива строк, а возвращает Bool. Если хотя бы одна из строк пуста - вернуть nil. В противном случае получить из массива строк массив целых чисел и вернуть, есть ли повторяющиеся элементы на одних и тех же местах (на помощь придет функция из 3 задания)

func twoArrs (arr1: [String], arr2: [String]) -> Bool? {
    guard !arr1.isEmpty || !arr2.isEmpty else {
        return nil
    }
    var a:[Int] = []
    var b:[Int] = []
    
    for elementArr1 in arr1 {
        for i in elementArr1 {
            if let num = Int(String(i)) {//тут chatgpt подсказал, сам бы не догадался что через распаковку надо решать (спросил, конечно не все задание, а только "как перебрать элементы string и если там есть целые числа сделать из них массив Int?"
                a.append(num)
            }
        }
    }
    for elementArr2 in arr2 {
        for i in elementArr2 {
            if let num = Int(String(i)) {
                b.append(num)
            }
        }
    }
    return hasCommonElementsAtSameIndices(arr1: a, arr2: b)
}


twoArrs(arr1: ["234asd", "234asd"], arr2: ["234asd", "234asd"])

var a = [1, 2, 3]
print(a[1])
